<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<link rel="STYLESHEET" href="../term_tools/main.css" type="text/css">
<title>grep MAN Page</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><!-- #BeginLibraryItem "/Library/head_bash.lbi" --><div id="nav-menu">
<ul>
<li><a class="rl" href="../term_tools/index.html"><img src="../term_tools/images/ss64.gif" title="Home" alt="Home"></a></li>
<li><a class="rl" href="../term_tools/bash"><img src="../term_tools/images/bash-l.gif" title="bash" alt="bash"></a></li>
<li><!-- Search Google -->
<form action="http://www.google.com/search" method="get" style="margin:0px;padding:0px;">
<div align="right">
<input name="q" type="text" class="body" size="25">
<input class="submit" type="submit" value="Search">
<input type="hidden" name="q" value="site:ss64.com/bash/">
</div>
</form></li>
<li><a class="rr" href="syntax.html"><img src="../term_tools/images/syntax-r.gif" title="Bash Syntax"></a></li>
</ul>
</div> <!-- #EndLibraryItem --><h1> grep</h1> 
<p>Search file(s) for specific text. </p>
<pre>SYNTAX
      grep &lt;<em>options</em>&gt; &quot;<em>Search String</em>&quot; [<em>filename</em>]

      grep &lt;<em>options</em>&gt; [-e <em>pattern</em>] [<em>file</em>...]

      grep &lt;<em>options</em>&gt; [-f <em>file</em>] [<em>file</em>...]

A simple example:
$grep "Needle in a Haystack" /etc/*

OPTIONS

-A <em>NUM</em>
--after-context=<em>NUM</em>
     (GNU Extension)
     Print <em>NUM</em> lines of trailing context after matching lines.

-a
--text
     (GNU Extension)
     Do not suppress output lines that contain binary data.  Normally,
     if the first few bytes of a file indicate that the file contains
     binary data, grep outputs only a message saying that the file
     matches the pattern.  This option causes grep to act as if the
     file is a text file, even if it would otherwise be treated as
     binary.  _Warning:_ the result might be binary garbage printed to
     the terminal, which can have nasty side-effects if the terminal
     driver interprets some of it as commands.

-B <em>NUM</em>
--before-context=<em>NUM</em>
     (GNU Extension)
     Print NUM lines of leading context before matching lines.

-b
--byte-offset
     (GNU Extension)
     Print the byte offset within the input file before each line of
     output.  When `grep' runs on MS-DOS or MS-Windows, the printed
     byte offsets depend on whether the `-u' (`--unix-byte-offsets')
     option is used; see below.

-C <em>NUM</em>
--context=[<em>NUM</em>]
     (GNU Extension)
     Print NUM lines (default 2) of output context.

-c
--count
     Suppress normal output; instead print a count of matching lines
     for each input file.  With the `-v', `--invert-match' option,
     count non-matching lines.

-d <em>ACTION</em>
--directories=<em>ACTION</em>
     (GNU Extension)
     If an input file is a directory, use ACTION to process it.  By
     default, ACTION is `read', which means that directories are read
     just as if they were ordinary files (some operating systems and
     filesystems disallow this, and will cause `grep' to print error
     messages for every directory).  If ACTION is `skip', directories
     are silently skipped.  If ACTION is `recurse', `grep' reads all
     files under each directory, recursively; this is equivalent to the
     `-r' option.

-e <em>PATTERN</em>
--regexp=<em>PATTERN</em>
     Use <em>PATTERN</em> as the <a href="../term_tools/bash/grep2.html">pattern</a>; useful to protect patterns beginning
     with a -

-f <em>FILE</em>
--file=<em>FILE</em>
     Obtain <a href="../term_tools/bash/grep2.html">patterns</a> from <em>FILE</em>, one per line.  The empty file contains
     zero patterns, and therefore matches nothing.

-H
--with-filename
     (GNU Extension)
     Print the filename for each match.

-h
--no-filename
     (GNU Extension)
     Suppress the prefixing of filenames on output when multiple files
     are searched.

--help
     (GNU Extension)
     Print a usage message briefly summarizing these command-line
     options and the bug-reporting address, then exit.

-i
--ignore-case
     Ignore case distinctions in both the pattern and the input files.

-L
--files-without-match
     (GNU Extension)
     Suppress normal output; instead print the name of each input file
     from which no output would normally have been printed.  The
     scanning of every file will stop on the first match.

-l
--files-with-matches
     Suppress normal output; instead print the name of each input file
     from which output would normally have been printed.  The scanning
     of every file will stop on the first match.

--mmap
     (GNU Extension)
     If possible, ue the `mmap' system call to read input, instead of
     the default `read' system call.  In some situations, `--mmap'
     yields better performance.  However, `--mmap' can cause undefined
     behavior (including core dumps) if an input file shrinks while
     `grep' is operating, or if an I/O error occurs.

-n
--line-number
     Prefix each line of output with the line number within its input
     file.

-<em>NUM</em>
     (GNU Extension)
     Same as `--context=<em>NUM</em>' lines of leading and trailing context.
     However, grep will never print any given line more than once.

-q
--quiet
--silent
     Quiet; suppress normal output.  The scanning of every file will
     stop on the first match.  Also see the `-s' or `--no-messages'
     option.

-r
--recursive
     (GNU Extension)
     For each directory mentioned in the command line, read and process
     all files in that directory, recursively.  This is the same as the
     `-d recurse' option.

-s
--no-messages
     Suppress error messages about nonexistent or unreadable files.
     Portability note: unlike GNU `grep', traditional `grep' did not
     conform to POSIX.2, because traditional `grep' lacked a `-q'
     option and its `-s' option behaved like GNU `grep''s `-q' option.
     Shell scripts intended to be portable to traditional `grep' should
     avoid both `-q' and `-s' and should redirect output to `/dev/null'
     instead.

-U
--binary
     (GNU Extension)
     Treat the file(s) as binary.  By default, under MS-DOS and
     MS-Windows, `grep' guesses the file type by looking at the
     contents of the first 32kB read from the file.  If `grep' decides
     the file is a text file, it strips the `CR' characters from the
     original file contents (to make regular expressions with `^' and
     `$' work correctly).  Specifying `-U' overrules this guesswork,
     causing all files to be read and passed to the matching mechanism
     verbatim; if the file is a text file with `CR/LF' pairs at the end
     of each line, this will cause some regular expressions to fail.
     This option has no effect on platforms other than MS-DOS and
     MS-Windows.

-u
--unix-byte-offsets
     (GNU Extension)
     Report Unix-style byte offsets.  This switch causes `grep' to
     report byte offsets as if the file were Unix style text file,
     i.e., the byte offsets ignore the `CR' characters which were
     stripped.  This will produce results identical to running `grep' on
     a Unix machine.  This option has no effect unless `-b' option is
     also used; it has no effect on platforms other than MS-DOS and
     MS-Windows.

-v
--invert-match
     Invert the sense of matching, to select non-matching lines.

-V
--version
     (GNU Extension)
     Print the version number of `grep' to the standard output stream.
     This version number should be included in all bug reports.

-w
--word-regexp
     (GNU Extension)
     Select only those lines containing matches that form whole words.
     The test is that the matching substring must either be at the
     beginning of the line, or preceded by a non-word constituent
     character.  Similarly, it must be either at the end of the line or
     followed by a non-word constituent character.  Word-constituent
     characters are letters, digits, and the underscore.

-x
--line-regexp
     Select only those matches that exactly match the whole line.

-Z
--null
     (GNU Extension)
     Output a zero byte (the ASCII `NUL' character) instead of the
     character that normally follows a file name.  For example, `grep
     -lZ' outputs a zero byte after each file name instead of the usual
     newline.  This option makes the output unambiguous, even in the
     presence of file names containing unusual characters like
     newlines.  This option can be used with commands like `find
     -print0', `perl -0', `sort -z', and `xargs -0' to process
     arbitrary file names, even those that contain newline characters.

-z
--null-data
     (GNU Extension)
     Treat the input as a set of lines, each terminated by a zero byte
     (the ASCII `NUL' character) instead of a newline.  Like the `-Z'
     or `--null' option, this option can be used with commands like
     `sort -z' to process arbitrary file names.

<b>Environment variables</b>

Grep's behavior can be affected by setting the following environment variables

GREP_OPTIONS                 - default options
LANG                         - language for messages
POSIXLY_CORRECT              - Posix behaviour
_N_GNU_nonoption_argv_flags_ - ignore an operand

see `info' for more on these
</pre>
<p><span class="body">Grep stands for:  Global Regular Expression Print.</span></p>
<p>  <b>Diagnostics</b><br>
    <br>
  Normally, exit status is 0 if matches were found, and 1 if no matches
  were found (the `-v' option inverts the sense of the exit status).<br> Exit status is 2 if there were syntax errors in the pattern,
inaccessible input files, or other system errors.</p>
<p><b>Examples</b></p>
<p>Search the file example.txt, including binary data (-a) for the string 'hunting the snark':</p>
<p>$ <span class="code">sudo grep -a 'hunting the snark' example.txt</span></p>
<p>Search the whole partition (/sda1), including binary data(-a) for the string 'hunting the snark' return all the lines starting 25 <b>B</b>efore the text found and 50 lines <b>A</b>fter the matching text found, this can be a way to discover fragments of deleted files but is very slow:</p>
<p>$ <span class="code">grep -a -B 25 -A 50 'hunting the snark' /dev/sda1</span> &gt; results.txt</p>
<p><i>&quot;I understand that change is frightening for people, especially 
  if there's nothing to go to. It's best to stay where you are. I understand that.&quot; - <a href="http://www.bbc.co.uk/politics97/diana/panorama.html">Princess 
  Diana</a> </i><br>
  <br>
  <b> Related</b>:<br>
  <br>
  <a href="egrep.html">egrep</a> - Search file(s) for lines that match an extended 
  expression<br>
  <a href="fgrep.html">fgrep</a> - Search file(s) for lines that match a fixed 
  string<br>
  <a href="awk.html">gawk</a> - Find and Replace text within file(s)<br>
  <a href="sed.html">sed</a> - Stream Editor - Find and Replace text within file(s)  <br>
  <a href="tr.html">tr</a> - Translate, squeeze, and/or delete characters <br>
Equivalent Windows commands: <a href="../term_tools/nt/qgrep.html">QGREP</a> / <a href="../term_tools/nt/findstr.html">FINDSTR</a> - Search for strings in files </p>
<!-- #BeginLibraryItem "/Library/foot_bash.lbi" --><p align="left"><script type="text/javascript"><!--
google_ad_client = "pub-6140977852749469";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "text_image";
google_ad_channel ="1984328893";
google_color_border = "CCCCCC";
google_color_bg = "CCCCCC";
google_color_link = "000000";
google_color_text = "333333";
google_color_url = "0000FF";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br>
</p>
<div align="center"><hr size="1">
  <p id="top"><a href="#"><img src="../term_tools/images/top-4.gif" width="47" height="53" border="0" alt="Back to the Top" title="Back to the Top"></a></p>
  <p class="tagline">&copy; Copyright <a href="http://ss64.com/">SS64.com</a> 1999-2010<br>
Some rights reserved<br>
</p>
</div><!-- #EndLibraryItem --></body>
</html>
